Fast and works with C++

    Performance matching C++ using LLVM, with low-level access to bits and addresses
    Interoperate with your existing C++ code, from inheritance to templates
    Fast and scalable builds that work with your existing C++ build systems

Modern and evolving

    Solid language foundations that are easy to learn, especially if you have used C++
    Easy, tool-based upgrades between Carbon versions
    Safer fundamentals, and an incremental path towards a memory-safe subset

Welcoming open-source community

    Clear goals and priorities with robust governance
    Community that works to be welcoming, inclusive, and friendly
    Batteries-included approach: compiler, libraries, docs, tools, package manager, and more

Why build Carbon?

C++ remains the dominant programming language for performance-critical software, with massive and growing codebases and investments. However, it is struggling to improve and meet developers' needs, as outlined above, in no small part due to accumulating decades of technical debt. Incrementally improving C++ is extremely difficult, both due to the technical debt itself and challenges with its evolution process. The best way to address these problems is to avoid inheriting the legacy of C or C++ directly, and instead start with solid language foundations like modern generics system, modular code organization, and consistent, simple syntax.

Existing modern languages already provide an excellent developer experience: Go, Swift, Kotlin, Rust, and many more. Developers that can use one of these existing languages should. Unfortunately, the designs of these languages present significant barriers to adoption and migration from C++. These barriers range from changes in the idiomatic design of software to performance overhead.

Carbon is fundamentally a successor language approach, rather than an attempt to incrementally evolve C++. It is designed around interoperability with C++ as well as large-scale adoption and migration for existing C++ codebases and developers. A successor language for C++ requires:

    Performance matching C++, an essential property for our developers.
    Seamless, bidirectional interoperability with C++, such that a library anywhere in an existing C++ stack can adopt Carbon without porting the rest.
    A gentle learning curve with reasonable familiarity for C++ developers.
    Comparable expressivity and support for existing software's design and architecture.
    Scalable migration, with some level of source-to-source translation for idiomatic C++ code.

With this approach, we can build on top of C++'s existing ecosystem, and bring along existing investments, codebases, and developer populations. There are a few languages that have followed this model for other ecosystems, and Carbon aims to fill an analogous role for C++:

    JavaScript → TypeScript
    Java → Kotlin
    C++ → Carbon

Language Goals

We are designing Carbon to support:

    Performance-critical software
    Software and language evolution
    Code that is easy to read, understand, and write
    Practical safety and testing mechanisms
    Fast and scalable development
    Modern OS platforms, hardware architectures, and environments
    Interoperability with and migration from existing C++ code

While many languages share subsets of these goals, what distinguishes Carbon is their combination.

We also have explicit non-goals for Carbon, notably including:

    A stable application binary interface (ABI) for the entire language and library
    Perfect backwards or forwards compatibility

Our detailed goals document fleshes out these ideas and provides a deeper view into our goals for the Carbon project and language.
Project status

Carbon Language is currently an experimental project. There is no working compiler or toolchain. You can see the demo interpreter for Carbon on compiler-explorer.com.

We want to better understand whether we can build a language that meets our successor language criteria, and whether the resulting language can gather a critical mass of interest within the larger C++ industry and community.

Currently, we have fleshed out several core aspects of both Carbon the project and the language:

    The strategy of the Carbon Language and project.
    An open-source project structure, governance model, and evolution process.
    Critical and foundational aspects of the language design informed by our experience with C++ and the most difficult challenges we anticipate. This includes designs for:
        Generics
        Class types
        Inheritance
        Operator overloading
        Lexical and syntactic structure
        Code organization and modular structure
    A prototype interpreter demo that can both run isolated examples and gives a detailed analysis of the specific semantic model and abstract machine of Carbon. We call this the Carbon Explorer.

If you're interested in contributing, we would love help completing the 0.1 language designs, and completing the Carbon Explorer implementation of this design. We are also currently working to get more broad feedback and participation from the C++ community. Beyond that, we plan to prioritize C++ interoperability and a realistic toolchain that implements the 0.1 language and can be used to evaluate Carbon in more detail.

You can see our full roadmap for more details.
Carbon and C++

If you're already a C++ developer, Carbon should have a gentle learning curve. It is built out of a consistent set of language constructs that should feel familiar and be easy to read and understand.
Generics

Carbon provides a modern generics system with checked definitions, while still supporting opt-in templates for seamless C++ interop. Checked generics provide several advantages compared to C++ templates:

    Generic definitions are fully type-checked, removing the need to instantiate to check for errors and giving greater confidence in code.
        Avoids the compile-time cost of re-checking the definition for every instantiation.
        When using a definition-checked generic, usage error messages are clearer, directly showing which requirements are not met.
    Enables automatic, opt-in type erasure and dynamic dispatch without a separate implementation. This can reduce the binary size and enables constructs like heterogeneous containers.
    Strong, checked interfaces mean fewer accidental dependencies on implementation details and a clearer contract for consumers.

Without sacrificing these advantages, Carbon generics support specialization, ensuring it can fully address performance-critical use cases of C++ templates. For more details about Carbon's generics, see their design.

In addition to easy and powerful interop with C++, Carbon templates can be constrained and incrementally migrated to checked generics at a fine granularity and with a smooth evolutionary path.
Memory safety

Safety, and especially memory safety, remains a key challenge for C++ and something a successor language needs to address. Our initial priority and focus is on immediately addressing important, low-hanging fruit in the safety space:

    Tracking uninitialized states better, increased enforcement of initialization, and systematically providing hardening against initialization bugs when desired.
    Designing fundamental APIs and idioms to support dynamic bounds checks in debug and hardened builds.
    Having a default debug build mode that is both cheaper and more comprehensive than existing C++ build modes even when combined with Address Sanitizer.

Once we can migrate code into Carbon, we will have a simplified language with room in the design space to add any necessary annotations or features, and infrastructure like generics to support safer design patterns. Longer term, we will build on this to introduce a safe Carbon subset. This will be a large and complex undertaking, and won't be in the 0.1 design. Meanwhile, we are closely watching and learning from efforts to add memory safe semantics onto C++ such as Rust-inspired lifetime annotations.